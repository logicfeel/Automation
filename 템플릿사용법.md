# 템플릿 사용법

## Template.init() 오버라이딩 의 경우

- 통합 실행시 (default) : `실행` 후 자동화 처리 (템플릿은 마지막에 실행)
    - TODO: 자신 및 하위에 결과를 남겨둘 경우 (data, 코드 등)?
- 단독 실행시 (template) : 템플릿 처리전에 `실행`


## Template.before_template() 오버라이딩 의 경우

- 통합 실행시 (default) : 자동화 처리시 후 템플릿 처리전에 `실행`
- 단독 실행시 (template) : 템플릿 처리전에 `실행`

## Template.src 사용법

> Template.src.add() : 추가

```javascript 
/***
 * - 파일로 접두사 : @
 * - 파일 확장자 : .hbs
 * - 경로 : src/
 * this.src.add('경로/속성명', '내용');
 */

// 내부경로 있고, 내용 있음
this.src.add('sub/title.html', '{{PKG.name}}');
// 저장명 : src/sub/@title.html.hbs
// 내용 : {{PKG.name}}
// 배치1 : dist/sub/@title.html  <= REVIEW: @ 빼야 맞을지?
// 배치2 : dist/sub/title.html

// 경로 있고, 내용 없음
this.src.add('title.asp');  
// 저장명 : src/@title.asp.hbs
// 내용 : [없음]
// 배치 : dist/title.html

// 외부모듈의 템플릿 추가
// 주의! : 종속 조각이 있는 경우 에러 발생, 다독 부분만 삽입
var t = this.import('mn_view');
this.src.add('title.asp');
this.src['title.asp'] = t.src['view.asp'];
// 저장명 : src/@title.asp.hbs
// 내용 : [모듈 view 템플릿의 내용]
```

> Template.src[*] : 변경
```javascript 
// 기존 소스 setter 지역속성(data,deco) 지정후 단독 컴파일한 경우
this.getTitle('제목입니다.');
this.src['title.asp'].compile();
// 저장명 : src/@compile/title.asp.hbs
// 내용 : [내부 속성의 변경 반영된 내용]
```

> Template.src[*] : 복제
```javascript 
// 자신 복제
// 방식1
this.src.add('title2.asp', this.src['title.asp']);
// 방식2
this.src.add('title2.asp');
this.src['title2.asp'] = this.src['title.asp'];
// 저장명 : src/@compile/title2.asp.hbs
// 배치 : dist/@compile/title2.asp
```

## Template.page 사용법
> `src` 와 사용법 같음
> 다른점 : 배치 `publish/` 기준으로 설치됨

## Template.part 사용법

> Template.part[*] : 동적 템플릿
```javascript 
// 동적 템플릿 추가
var outMod = require('outMod');
this.part.add('title.asp', outMod);
// 저장명 : template/part/__title.asp.hbs {참조용}
```

## Template.part.ns 사용법

> Template.namespace[*] : 추가 (외부모듈) - {.hbs, .js}
> REVIEW: .js 모듈의 경우 확장다를 다르게 저장해야 하는지 ?
> REVIEW: 네임스페이스는 컴파일 비지원이 맞을듯?
```javascript 
// 동적 템플릿 추가
var t = this.import('mn_view');

// 방법1
this.namespace.add('asp/sqlparam', t.namespace['asp/sqlparam']);
// 방법2
this.namespace.add(t.namespace['asp/sqlparam']);
// 저장명 : template/part/ns/asp/__sqlparam.hbs {참조용}
```

> Template.namespace[*] : 추가 (내부)
```javascript 
// 동적 템플릿 추가
this.namespace.add('asp/sqlparam', '{{PKG.name}}');
// 저장명 : template/part/ns/asp/__sqlparam.hbs {참조용}
```

## src, page, part, namespace 컴파일 사용법

> src, page, part, namespace : 컴파일
```javascript 
// 신규 생성 후 단독 컴파일의 경우
this.src.add('title.asp', '{{PKG.name}}');
this.src['title.asp'].compile(data);
// 저장명 : src/@title.asp.hbs
// 저장명 : src/@compile/title.asp.hbs
// 내용 : [해석된 템플릿 내용]

// 신규 생성 후 지역속성(data,deco) 지정후 단독 컴파일한 경우
this.src.add('title.asp', '{{PKG.name}}');
this.src['title.asp'].partials('');     // REVIEW: import 추가 여부
this.src['title.asp'].data('');         // REVIEW: import 추가 여부
this.src['title.asp'].compile(data);
```

## Template.data 사용법

> 동적 데이터 사용
> REVIEW: 정의 부분과의 연동 필요한지?
> 동적/정적 데이터 접근방식은 동일함
```javascript 
// 내부적으로 setter 사용하여 값 설정
this.data['entity'].title = '제목임';

// 내부적으로 getter 사용하여 값 받음
var title = this.data['entity'].title;
```

> 외부 모듈 데이터 사용 (데이터 인스턴스 수정)
```javascript 
var t = this.import('mn_view');
t.data['table'].fixname ='접두사';
this.data['entity'].title = t.data['table'].view;

// 내부적으로 getter 사용하여 값 받음
var title = this.data['entity'].title;
```

## Template.helper 사용법

> 핼퍼(기능/블럭문법) if, for ...
> 복제해서 사용을 원칙
```javascript 
var t = this.import('mn_view');
// 방식1
this.helper.add('for', t.src['for']);
// 방식2
this.helper.add('for');
this.helper['for'] = t.src['for'];
```

## Template.decorator 사용법

